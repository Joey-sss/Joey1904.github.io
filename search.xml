<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java Basics</title>
      <link href="/2022/04/23/Java%20Basics/"/>
      <url>/2022/04/23/Java%20Basics/</url>
      
        <content type="html"><![CDATA[<p>一、Java 基础知识<br>1、Object 类相关方法<br>getClass 获取当前运行时对象的 Class 对象。<br>hashCode 返回对象的 hash 码。<br>clone 拷贝当前对象， 必须实现 Cloneable 接口。浅拷贝对基本类型进行值拷贝，对引用类型拷贝引用；深拷贝对基本类型进行值拷贝，对引用类型对象不但拷贝对象的引用还拷贝对象的相关属性和方法。两者不同在于深拷贝创建了一个新的对象。<br>equals 通过内存地址比较两个对象是否相等，String 类重写了这个方法使用值来比较是否相等。<br>toString 返回类名@哈希码的 16 进制。<br>notify 唤醒当前对象监视器的任一个线程。<br>notifyAll 唤醒当前对象监视器上的所有线程。<br>wait 1、暂停线程的执行；2、三个不同参数方法（等待多少毫秒；额外等待多少毫秒；一直等待）3、与 Thread.sleep(long time) 相比，sleep 使当前线程休眠一段时间，并没有释放该对象的锁，wait 释放了锁。<br>finalize 对象被垃圾回收器回收时执行的方法。<br>2、基本数据类型<br>整型：byte(8)、short(16)、int(32)、long(64)<br>浮点型：float(32)、double(64)<br>布尔型：boolean(8)<br>字符型：char(16)<br>3、序列化<br>Java 对象实现序列化要实现 Serializable 接口。</p><p>反序列化并不会调用构造方法。反序列的对象是由 JVM 自己生成的对象，不通过构造方法生成。<br>序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。<br>如果想让某个变量不被序列化，使用 transient 修饰。<br>单例类序列化，需要重写 readResolve() 方法。<br>4、String、StringBuffer、StringBuilder<br>String 由 char[] 数组构成，使用了 final 修饰，是不可变对象，可以理解为常量，线程安全；对 String 进行改变时每次都会新生成一个 String 对象，然后把指针指向新的引用对象。<br>StringBuffer 线程安全；StringBuiler 线程不安全。<br>操作少量字符数据用 String；单线程操作大量数据用 StringBuilder；多线程操作大量数据用 StringBuffer。<br>5、重载与重写<br>重载 发生在同一个类中，方法名相同，参数的类型、个数、顺序不同，方法的返回值和修饰符可以不同。<br>重写 发生在父子类中，方法名和参数相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 或者 final 则子类就不能重写该方法。<br>6、final<br>修饰基本类型变量，一经出初始化后就不能够对其进行修改。<br>修饰引用类型变量，不能够指向另一个引用。<br>修饰类或方法，不能被继承或重写。<br>7、反射<br>在运行时动态的获取类的完整信息<br>增加程序的灵活性<br>JDK 动态代理使用了反射<br>8、JDK 动态代理<br>使用步骤<br>创建接口及实现类<br>实现代理处理器：实现 InvokationHandler ，实现 invoke（Proxy proxy，Method method，Object[] args） 方法<br>通过 Proxy.newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h) 获得代理类<br>通过代理类调用方法。<br>9、Java IO<br>普通 IO ，面向流，同步阻塞线程。<br>NIO，面向缓冲区，同步非阻塞。<br>二、Java 集合框架<br>1、List（线性结构）<br>ArrayList Object[] 数组实现，默认大小为 10 ，支持随机访问，连续内存空间，插入末尾时间复杂度 o(1)，插入第 i 个位置时间复杂度 o(n - i)。扩容，大小变为 1.5 倍，Arrays.copyOf（底层 System.ArrayCopy），复制到新数组，指针指向新数组。<br>Vector 类似 ArrayList，线程安全，扩容默认增长为原来的 2 倍，还可以指定增长空间长度。<br>LinkedList 基于链表实现，1.7 为双向链表，1.6 为双向循环链表，取消循环更能分清头尾。<br>2、Map（K，V 对）<br>HashMap<br>底层数据结构，JDK 1.8 是数组 + 链表 + 红黑树，JDK 1.7 无红黑树。链表长度大于 8 时，转化为红黑树，优化查询效率。<br>初始容量为 16，通过 tableSizeFor 保证容量为 2 的幂次方。寻址方式，高位异或，(n-1)&amp;h 取模，优化速度。<br>扩容机制，当元素数量大于容量 x 负载因子 0.75 时，容量扩大为原来的 2 倍，新建一个数组，然后转移到新数组。<br>基于 Map 实现。<br>线程不安全。<br>HashMap (1.7) 多线程循环链表问题<br>在多线程环境下，进行扩容时，1.7 下的 HashMap 会形成循环链表。<br>怎么形成循环链表： 假设有一 HashMap 容量为 2 ， 在数组下标 1 位置以 A -&gt; B 链表形式存储。有一线程对该 map 做 put 操作，由于触发扩容条件，需要进行扩容。这时另一个线程也 put 操作，同样需要扩容，并完成了扩容操作，由于复制到新数组是头部插入，所以 1 位置变为 B -&gt; A 。这时第一个线程继续做扩容操作，首先复制 A ，然后复制 B ，再判断 B.next 是否为空时，由于第二个线程做了扩容操作，导致 B.next &#x3D; A，所以在将 A 放到 B 前，A.next 又等于 B ，导致循环链表出现。<br>HashTable<br>线程安全，方法基本全用 Synchronized 修饰。<br>初始容量为 11 ，扩容为 2n + 1 。<br>继承 Dictionary 类。<br>ConcurrentHashMap<br>线程安全的 HashMap。<br>1.7 采用分段锁的形式加锁；1.8 使用 Synchronized 和 CAS 实现同步，若数组的 Node 为空，则通过 CAS 的方式设置值，不为空则加在链表的第一个节点。获取第一个元素是否为空使用 Unsafe 类提供的 getObjectVolatile 保证可见性。<br>对于读操作，数组由 volatile 修饰，同时数组的元素为 Node，Node 的 K 使用 final 修饰，V 使用 volatile 修饰，下一个节点也用 volatile 修饰，保证多线程的可见性。<br>LinkedHashMap LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。<br>TreeMap 有序的 Map，红黑树结构，可以自定义比较器来进行排序。<br>Collections.synchronizedMap 如何实现 Map 线程安全？ 基于 Synchronized ，实际上就是锁住了当前传入的 Map 对象。<br>3、Set（唯一值）<br>HashSet 基于 HashMap 实现，使用了 HashMap 的 K 作为元素存储，V 为 new Object() ，在 add() 方法中如果两个元素的 Hash 值相同，则通过 equals 方法比较是否相等。<br>LinkedHashSet LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。<br>TreeSet 红黑树实现有序唯一。<br>三、Java 多线程<br>1、synchronized<br>修饰代码块 底层实现，通过 monitorenter &amp; monitorexit 标志代码块为同步代码块。<br>修饰方法 底层实现，通过 ACC_SYNCHRONIZED 标志方法是同步方法。<br>修饰类 class 对象时，实际锁在类的实例上面。<br>单例模式<br>public class Singleton {</p><pre><code>private static volatile Singleton instance = null;private Singleton()&#123;&#125;public static Singleton getInstance()&#123;if (null == instance) &#123;    synchronized (Singleton.class) &#123;        if (null == instance) &#123;        instance = new Singleton();        &#125;    &#125;  &#125;    return instance;    &#125;</code></pre><p>}<br>偏向锁，自旋锁，轻量级锁，重量级锁<br>通过 synchronized 加锁，第一个线程获取的锁为偏向锁，这时有其他线程参与锁竞争，升级为轻量级锁，其他线程通过循环的方式尝试获得锁，称自旋锁。若果自旋的次数达到一定的阈值，则升级为重量级锁。<br>需要注意的是，在第二个线程获取锁时，会先判断第一个线程是否仍然存活，如果不存活，不会升级为轻量级锁。<br>2、Lock<br>ReentrantLock<br>基于 AQS （AbstractQueuedSynchronizer）实现，主要有 state (资源) + FIFO (线程等待队列) 组成。<br>公平锁与非公平锁：区别在于在获取锁时，公平锁会判断当前队列是否有正在等待的线程，如果有则进行排队。<br>使用 lock() 和 unLock() 方法来加锁解锁。<br>ReentrantReadWriteLock<br>同样基于 AQS 实现，内部采用内部类的形式实现了读锁（共享锁）和写锁 （排它锁）。<br>非公平锁吞吐量高 在获取锁的阶段来分析，当某一线程要获取锁时，非公平锁可以直接尝试获取锁，而不是判断当前队列中是否有线程在等待。一定情况下可以避免线程频繁的上下文切换，这样，活跃的线程有可能获得锁，而在队列中的锁还要进行唤醒才能继续尝试获取锁，而且线程的执行顺序一般来说不影响程序的运行。<br>3、volatile<br>在多线程环境下，保证变量的可见性。使用了 volatile 修饰变量后，在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。<br>禁止 JVM 指令重排序。<br>单例模式双重校验锁变量为什么使用 volatile 修饰？ 禁止 JVM 指令重排序，new Object()分为三个步骤：申请内存空间，将内存空间引用赋值给变量，变量初始化。如果不禁止重排序，有可能得到一个未经初始化的变量。<br>4、线程的五种状态<br>1). New<br>一个新的线程被创建，还没开始运行。</p><p>2). Runnable<br>一个线程准备就绪，随时可以运行的时候就进入了 Runnable 状态。</p><p>Runnable 状态可以是实际正在运行的线程，也可以是随时可以运行的线程。</p><p>多线程环境下，每个线程都会被分配一个固定长度的 CPU 计算时间，每个线程运行一会儿就会停止让其他线程运行，这样才能让每个线程公平的运行。这些等待 CPU 和正在运行的线程就处于 Runnable 状态。</p><p>3). Blocked<br>例如一个线程在等待 I&#x2F;O 资源，或者它要访问的被保护代码已经被其他线程锁住了，那么它就在阻塞 Blocked 状态，这个线程所需的资源到位后就转入 Runnable 状态。</p><p>4). Waiting（无限期等待）<br>如果一个线程在等待其他线程的唤醒，那么它就处于 Waiting 状态。以下方法会让线程进入等待状态：</p><p>Object.wait()<br>Thread.join()<br>LockSupport.park()<br>5). Timed Waiting（有期限等待）<br>无需等待被其他线程显示唤醒，在一定时间后有系统自动唤醒。</p><p>以下方法会让线程进入有限等待状态：</p><p>Thread.sleep(sleeptime)<br>Object.wait(timeout)<br>Thread.join(timeout)<br>LockSupport.parkNanos(timeout)<br>LockSupport.parkUntil(timeout)<br>6). Terminated<br>一个线程正常执行完毕，或者意外失败，那么就结束了。</p><p>5、 wait() 与 sleep()<br>调用后线程进入 waiting 状态。<br>wait() 释放锁，sleep() 没有释放锁。<br>调用 wait() 后需要调用 notify() 或 notifyAll() 方法唤醒线程。<br>wait() 方法声明在 Object 中，sleep() 方法声明在 Thread 中。<br>6、 yield()<br>调用后线程进入 runnable 状态。<br>让出 CPU 时间片，之后有可能其他线程获得执行权，也有可能这个线程继续执行。<br>7、 join()<br>在线程 B 中调用了线程 A 的 Join()方法，直到线程 A 执行完毕后，才会继续执行线程 B。<br>可以保证线程的顺序执行。<br>join() 方法必须在 线程启动后调用才有意义。<br>使用 wait() 方法实现。<br>9、线程使用方式<br>继承 Tread 类<br>实现 Runnable 接口<br>实现 Callable 接口：带有返回值<br>10、Runnable 和 Callable 比较<br>方法签名不同， void Runnable.run() , V Callable.call() throws Exception<br>是否允许有返回值， Callable 允许有返回值<br>是否允许抛出异常， Callable 允许抛出异常。<br>提交任务方式， Callable 使用 Future<T> submit(Callable<T> task) 返回 Future 对象，调用其 get() 方法可以获得返回值， Runnable 使用 void execute(Runnable command) 。<br>11、hapens-before<br>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p><p>12、ThreadLocal<br>场景 主要用途是为了保持线程自身对象和避免参数传递，主要适用场景是按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。<br>原理 为每个线程创建变量副本，不同线程之间不可见，保证线程安全。使用 ThreadLocalMap 存储变量副本，以 ThreadLocal 为 K，这样一个线程可以拥有多个 ThreadLocal 对象。<br>实际 使用多数据源时，需要根据数据源的名字切换数据源，假设一个线程设置了一个数据源，这个时候就有可能有另一个线程去修改数据源，可以使用 ThreadLocal 维护这个数据源名字，使每个线程持有数据源名字的副本，避免线程安全问题。<br>8、线程池<br>1)、分类<br>FixThreadPool 固定数量的线程池，适用于对线程管理，高负载的系统<br>SingleThreadPool 只有一个线程的线程池，适用于保证任务顺序执行<br>CacheThreadPool 创建一个不限制线程数量的线程池，适用于执行短期异步任务的小程序，低负载系统<br>ScheduledThreadPool 定时任务使用的线程池，适用于定时任务<br>2)、线程池的几个重要参数<br>int corePoolSize, 核心线程数<br>int maximumPoolSize, 最大线程数<br>long keepAliveTime, TimeUnit unit, 超过 corePoolSize 的线程的存活时长，超过这个时间，多余的线程会被回收。<br>BlockingQueue workQueue, 任务的排队队列<br>ThreadFactory threadFactory, 新线程的产生方式<br>RejectedExecutionHandler handler) 拒绝策略<br>3)、线程池线程工作过程<br>corePoolSize -&gt; 任务队列 -&gt; maximumPoolSize -&gt; 拒绝策略<br>核心线程在线程池中一直存活，当有任务需要执行时，直接使用核心线程执行任务。当任务数量大于核心线程数时，加入等待队列。当任务队列数量达到队列最大长度时，继续创建线程，最多达到最大线程数。当设置回收时间时，核心线程以外的空闲线程会被回收。如果达到了最大线程数还不能够满足任务执行需求，则根据拒绝策略做拒绝处理。<br>4)、线程池拒绝策略（默认抛出异常）<br>|:—|:—| | AbortPolicy | 抛出 RejectedExecutionException | | DiscardPolicy | 什么也不做，直接忽略 | | DiscardOldestPolicy | 丢弃执行队列中最老的任务，尝试为当前提交的任务腾出位置 | | CallerRunsPolicy | 直接由提交任务者执行这个任务 |</p><p>5)、如何根据 CPU 核心数设计线程池线程数量<br>IO 密集型 2nCPU<br>计算密集型 nCPU+1<br>其中 n 为 CPU 核心数量，可通过 Runtime.getRuntime().availableProcessors() 获得核心数：。<br>为什么加 1：即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保 CPU 的时钟周期不会被浪费。<br>四、Java 虚拟机<br>1、Java 内存结构<br>堆 由线程共享，存放 new 出来的对象，是垃圾回收器的主要工作区域。<br>栈 线程私有，分为 Java 虚拟机栈和本地方法栈，存放局部变量表、操作栈、动态链接、方法出口等信息，方法的执行对应着入栈到出栈的过程。<br>方法区 线程共享，存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等信息，JDK 1.8 中方法区被元空间取代，使用直接内存。<br>2、Java 类加载机制<br>加载 加载字节码文件。<br>链接<br>验证 验证字节码文件的正确性。<br>准备 为静态变量分配内存。<br>解析 将符号引用（如类的全限定名）解析为直接引用（类在实际内存中的地址）。<br>初始化 为静态变量赋初值。<br>双亲委派模式</p><p>当一个类需要加载时，判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。</p><p>3、垃圾回收算法<br>Mark-Sweep（标记-清除）算法 标记需要回收的对象，然后清除，会造成许多内存碎片。<br>Copying（复制）算法 将内存分为两块，只使用一块，进行垃圾回收时，先将存活的对象复制到另一块区域，然后清空之前的区域。<br>Mark-Compact（标记-整理）算法（压缩法） 与标记清除算法类似，但是在标记之后，将存活对象向一端移动，然后清除边界外的垃圾对象。<br>Generational Collection（分代收集）算法 分为年轻代和老年代，年轻代时比较活跃的对象，使用复制算法做垃圾回收。老年代每次回收只回收少量对象，使用标记整理法。<br>4、典型垃圾回收器<br>CMS</p><p>简介 以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是 Mark-Sweep 算法。<br>场景 如果你的应用需要更快的响应，不希望有长时间的停顿，同时你的 CPU 资源也比较丰富，就适合适用 CMS 收集器。<br>垃圾回收步骤<br>初始标记 (Stop the World 事件 CPU 停顿， 很短) 初始标记仅标记一下 GC Roots 能直接关联到的对象，速度很快；<br>并发标记 (收集垃圾跟用户线程一起执行) 并发标记过程就是进行 GC Roots 查找的过程；<br>重新标记 (Stop the World 事件 CPU 停顿，比初始标记稍微长，远比并发标记短) 修正由于并发标记时应用运行产生变化的标记。<br>并发清理，标记清除算法；<br>缺点<br>并发标记时和应用程序同时进行，占用一部分线程，所以吞吐量有所下降。<br>并发清除时和应用程序同时进行，这段时间产生的垃圾就要等下一次 GC 再清除。<br>采用的标记清除算法，产生内存碎片，如果要新建大对象，会提前触发 Full GC 。<br>G1</p><p>简介 是一款面向服务端应用的收集器，它能充分利用多 CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型，即可以设置 STW 的时间。<br>垃圾回收步骤 1、初始标记(stop the world 事件 CPU 停顿只处理垃圾)； 2、并发标记(与用户线程并发执行)； 3、最终标记(stop the world 事件 ,CPU 停顿处理垃圾)； 4、筛选回收(stop the world 事件 根据用户期望的 GC 停顿时间回收)<br>特点<br>并发与并行 充分利用多核 CPU ，使用多核来缩短 STW 时间，部分需要停顿应用线程的操作，仍然可以通过并发保证应用程序的执行。<br>分代回收 新生代，幸存带，老年代<br>空间整合 总体看是采用标记整理算法回收，每个 Region 大小相等，通过复制来回收。<br>可预测的停顿时间 使用 -XX:MaxGCPauseMillis&#x3D;200 设置最长目标暂停值。<br>在 Java 语言中，可作为 GC Roots 的对象包括 4 种情况：</p><p>a) 虚拟机栈中引用的对象（栈帧中的本地变量表）； b) 方法区中类静态属性引用的对象； c) 方法区中常量引用的对象； d) 本地方法栈中 Native 方法引用的对象。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>奋斗，打工人！</title>
      <link href="/2022/04/20/Notes1/"/>
      <url>/2022/04/20/Notes1/</url>
      
        <content type="html"><![CDATA[<p>早安，打工人!</p><p>01.打工人 打工魂 打工人都是人上人！！</p><p>02.累吗？累就对了，舒服是留给有钱人的。早安，打工人！</p><p>03.冷吗？冷就对了，温暖是留给开小轿车的人。早安，共享单车人！</p><p>04.难吗？难就对了，只要我们不努力，总有一天没饭吃。早安，打工人！</p><p>05.没有困难的工作，只有勇敢的打工人</p><p>06.早上好 在天愿作比翼鸟 在地怨为打工人。</p><p>07.有人夜夜笙歌，有人一大早为生活奔波，早安打工人。</p><p>08.打工可能会少活十年，不打工你一天也活不下去。早点睡，打工人。</p><p>09.生活里80%的痛苦来源于打工 但是我知道 如果不打工 就会有100%的痛苦来源于没钱 所以在打工和没钱之间 我选择打工 ——《打工宣言》</p><p>10.敢上九天揽月，敢下五洋捉鳖，但却不敢迟到。因为迟到扣钱，早安，打工人！</p><p>11.有人相爱，有人夜里看海，有人七八个闹钟起不来，早安打工人！</p><p>12.头等舱可以优先登机，银行VIP可以不用排队，演唱会最贵的票位置也最好，世界从不平等，你有多努力，就有多特殊，早安，打工人！</p><p>13.这么不努力，怎么做打工人啊你</p><p>14.早安，打工人 说“上班”，就感觉像是为生活所迫，不情不愿。说“打工”，就像是带着美好的憧憬，用努力和汗水去创造未来早安！打工人们！</p><p>15.记住，打工才是王道，我们都要做打工人。人可以一天不吃饭，但不能一天不打工。打工让我们身心愉悦，节假日是掏空我们的身体。别睡了，打工仔，起床打工吧。</p><p>16.打工难吗？难。但是我不能哭，因为骑共享单车的手不允许用来擦眼泪。</p><p>17.靠别人是公主，靠你叽哇是日本人，靠北啦是台湾人，靠恁娘是河南人，靠自己是光荣的打工人，早安打工人！</p><p>18.我的人生规划本是在新加坡念高中 英国念本科 美国念研究生 法国念博士 然后在加拿大没得病就孤独终老 得了病就安乐死 但是因为成绩太差没考上高中 美梦全破碎了 现在在深圳打工。</p><p>19.只要我够努力，老板一定会过上他想要的生活！早安！打工人！</p><p>20.干不完的活，睡不够的觉，喂不胖的钱包，买不起的貂，半辈子就挣了两个亿，一个失忆，一个回忆。早安，打工人！</p><p>21.你的同事，要不就是拆二代体验生活，要不就是关系户整天吊儿郎当。只有你，是真正在为生活奔波的打工仔。加油，打工人！(ง •̀_•́)ง</p><p>22.爱情不是生活的全部，打工才是。 早安，打工人！</p><p>23.打工不仅能致富，还能交友娶媳妇。打工人，打工魂，打工都是人上人。家人们早上好!</p><p>24.很喜欢打工人的一句话：打工赚不了几个钱，但是多打几份工可以让你没时间花钱。</p><p>25.我带上了头盔，就无法吻你;摘下了头灰被交警罚款50。早安，打工人！</p><p>26.每天对着空气挥一拳，不为别的，就为干这个世界！早安，打工人！</p><p>27.不是工作需要我，而是我需要工作，我打工，我快乐。早安，打工人！</p><p>28.不拼爹，不拼娘，不拼工作，不拼钱，我们打工人只拼命。努力！打工人！</p><p>29.天气变冷不像夏天的砖那么烫手了，就是总下雨滑不溜丢的。加油，打工人！</p><p>30.10几岁的我心情不好可以翘课，20多岁的我再难过也得五点起床当保安。早安，打工人。</p><p>31.回你消息难吗 不难 可我在厂里干活 拿出手机罚200</p><p>32.世上有两种最耀眼的光芒，一种是太阳，一种是打工人努力的模样。早上好，打工人！</p><p>33.我要悄悄打工，然后惊艳所有人 !</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何培养强大的成长型思维</title>
      <link href="/2022/04/20/index/"/>
      <url>/2022/04/20/index/</url>
      
        <content type="html"><![CDATA[<p>　　在近十年左右的时间，你可能到处都能听到“成长型思维”这个词，许多播客、有影响力的人、自我提升专家等等。都在谈论成长思维是多么重要，这是我们所有人都应该努力培养的东西，但究竟什么是成长思维？为什么它如此重要？以及如果它真有那么好，我们该如何培养？­</p><p>­</p><p>“成长型思维”一词，是由美国心理学家卡罗尔·德威克博士，在研究了数千名儿童行为后首次提出的，在她的《看见成长的自己》一书中,德威克博士创造了两个术语：成长型思维和僵固型思维，这些术语能够帮助我们更好的理解人们对于自身的智力和学习能力的基本假设。本质上，僵固型思维描述的是一种观念，认为我们只能达到现在这样的智慧和才能，无论怎样的努力都无法再改变这些，那些僵固型思维的人，如果在第一次尝试某件事时没有做对，就会觉得自己很丢脸，因为他们经常会担心别人如何看待他们的智力、技术和能力。而另一方面，成长型思维的人，认为我们可以通过努力、付出和时间，变得更加聪明、娴熟，这种思维相信你可以成长、改变和提高。通过研究，德威克博士发现，具有成长型思维的学生明显优于具有僵固型思维的。相信自己有能力成长，事实上对信心和最终的成功都有很大影响。但这是为什么呢？事实证明，当你拥有成长型思维，你会更愿意尝试新事物，探索新的可能性，而且你不怕失败或经历挫折，因为你知道这些只是过程的一部分。德威克博士对于成长型思维的描述：“对挑战自己的热情，即使(或尤其是)在进展不顺利时坚持下去的决心，是成长型思维的标志，这样的心态使得人们在生活中最困难的时期也能够茁壮成长”。­</p><p>­</p><p>那么如果成长型思维能帮助学生变得成功、更快乐，我们该怎样才能培养自己的成长型思维呢？通过以下一些方法，你可以开始训练你的大脑，以成长型思维而不是僵固型思维来思考：­</p><p>­</p><ol><li>不再担心你是否够聪明，开始在意你是否够努力<br>正如德威克博士所说的：“光有天才是不够的，我们需要完成工作，在一天结束时，只要你能把事情完成，你有多聪明真的重要吗？根本不重要，最重要的是，你是否竭尽全力，要培养成长型思维，不要再根据你对自己聪明程度的认知来判断你的价值，而要开始专注于尽最大的努力，一路学习，并享受这一过程”。­</li></ol><p>­</p><ol start="2"><li>将失败视为学习的机会成长型思维的一个特点是，会将失败看作是学习的机会。僵固型思维的人会把失败看作是他们智力或技能水平的反映，于是当他们面对失败时就会选择放弃，但是，不要把失败看成是一件消极的事情，而要把它看作是一个学习的机会。这样行不通，你还可以用什么方法来代替？如果这一系列的行动得到的结果是失败，那么下次你如何改变才能获得成功？这是培养成长型思维的一个重要部分，能够使你保持前进不至落后。­</li></ol><p>­</p><ol start="3"><li>将挫折视为过程的一部分同样，重要的是要记住，挫折、失败、沮丧、失望等等，这些都是非常正常的。爱迪生试了多少次才发明出灯泡？奥普拉·温弗瑞的成名之路上，曾遇到多少挫折？你自己有多少次经历了挫折？还是选择继续前进？我们不需要为挫折或失败感到羞愧。而是要学着拥抱，从中学习、感激它，然后继续前进。­</li></ol><p>­</p><ol start="4"><li>赞扬努力而不是结果在德威克博士的书中，她写道：“在对数百名儿童进行七次实验后，我们有了一些非常清晰的发现：夸奖儿童的智力会使他们丧失动力，进而影响他们的表现。为什么会这样？孩子们不是喜欢被表扬吗？没错，孩子们喜欢被表扬，而且他们特别喜欢自己因为聪明和才能收到表扬，这的确能带给他们动力，一种特殊的荣耀，但这只是暂时的，一旦遇到困难，他们的信心就会消失，他们的积极性也会降至谷底，如果成功意味着他们聪明，那么失败就意味着他们愚笨，这就是僵固型思维”。德威克博士精妙地总结了僵固型思维潜伏的隐患：称赞本身并不总是有效的，即使是为自己感到自豪，从长远来看也可能会因此受到伤害。重要的是要记住，称赞你的智慧和才能并不能帮助你成长和学习，而表扬努力和坚韧不拔的精神，才是培养成长型思维和鼓励进步的更好方法。­</li></ol><p>­</p><ol start="5"><li>不要害怕问问题具有成长型思维的人经常表现出的一个特征是能够问问题，当然，我们都能够提问，但那些具有成长型思维的人并不害怕会因为这些问题而显得愚蠢、奇怪或不聪明。与其担心在提问时别人会如何看待你的智力，不如专注于努力学习和成长，你肯定做不到懂的一切，或者靠自己完成所有的事情。因此当你需要帮助时，大胆求助，如果不知道就问，这才是能够让你变得更有智慧的做法。正如德威克博士所写：“真正的自信是开放的勇气、欢迎变化和新的想法，无论其来源如何，真正的自信并不体现在一个头衔、一套昂贵的西装、一辆豪华的汽车或一系列的购置上，而是反映在你的心态上：你乐于成长。”­</li></ol><p>­</p><ol start="6"><li>接受新的挑战具有成长型思维的人深信，只要他们足够用心就能够学会并做到任何事情，但如果你目前停留在僵固型思维中，你可能很难立刻有这样的信心，因此，为了能够在行动中找到这样的信心，接受一个新的挑战，从一些小的、你知道你能够做到的事情开始，当你完成后，再继续做一些更困难的也许你不太确定能够做到的事情，逐渐地，你会意识到你完全有可能提高你的技艺、能力和才能，你只需要付出努力和时间。­</li></ol><p>­</p><p>德威克博士在她的书中写道：“我们喜欢把那些冠军和偶像看作是超级英雄，认为他们生来就与众不同，我们不喜欢把他们想成是相对普通的人，是他们自己造就了自己的不平凡”。为什么我们不喜欢这样想？也许是因为这样会让我们失去做不到像冠军和偶像那么出色的借口，也许是因为这意味着一直以来，阻碍我们的唯一因素只有我们自己，也许是因为如果我们接受了那些冠军和偶像，实际上只是努力的普通人，那么为了成功，我们也就必须努力。也许这听起来太累了，无论究竟是出于什么原因，一旦我们承认智力、天赋、技艺、能力等等，都可以通过努力得到提高，那么我们就拥有了无尽的可能性，有了成长型思维，一切都变得可能，你可以有一份更好的工作，你可以在化学考试中取得好成绩，当然你也会遇到挫折，但你的能力会提高。而且更重要的是，失败似乎也不再那么令人无望，挫折并不是你自我价值的反映，失败并不意味着该放弃了，他们只是意味着是时候做出转变了，难道这不是一种更令人兴奋、更快乐的生活方式吗？因此，在你有能力做到的一些小方面，开始探索拥有成长型思维的感觉，你可能会惊讶于你原来能够实现那么多事情。­</p><p>­</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
